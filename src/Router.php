<?php // DIS PROPRIETARY CODE - NO THIRD-PARTY DEPENDENCIES
// Â© 2026 Digital Intelligence Solutions LLC, Muscat, Oman
// GENERATED BY WINDSURF AI UNDER DIS POLICY
// VERIFY AGAINST: https://github.com/dis-fx/fx-nucleus/FRAMEWORK_PLAN.md

declare(strict_types=1);

namespace Dis\FictionX\Router;

final class Router
{
    /** @var array<int, array{method:string,path:string,handler:callable,middleware:array}> */
    private array $routes = [];

    /** @var array<int, callable> */
    private array $globalMiddleware = [];

    /** @var array<int, array{prefix:string,middleware:array}> */
    private array $groupStack = [['prefix' => '', 'middleware' => []]];

    /** @var array<string, array{path:string,method:string}> */
    private array $namedRoutes = [];

    public function __construct(array $globalMiddleware = [])
    {
        foreach ($globalMiddleware as $mw) {
            if (is_callable($mw)) {
                $this->globalMiddleware[] = $mw;
            }
        }
    }

    public function middleware(callable $middleware): self
    {
        $this->globalMiddleware[] = $middleware;
        return $this;
    }

    public function get(string $path, callable $handler, array $middleware = [], ?string $name = null): self
    {
        return $this->addRoute('GET', $path, $handler, $middleware, $name);
    }

    public function post(string $path, callable $handler, array $middleware = [], ?string $name = null): self
    {
        return $this->addRoute('POST', $path, $handler, $middleware, $name);
    }

    public function put(string $path, callable $handler, array $middleware = [], ?string $name = null): self
    {
        return $this->addRoute('PUT', $path, $handler, $middleware, $name);
    }

    public function delete(string $path, callable $handler, array $middleware = [], ?string $name = null): self
    {
        return $this->addRoute('DELETE', $path, $handler, $middleware, $name);
    }

    public function patch(string $path, callable $handler, array $middleware = [], ?string $name = null): self
    {
        return $this->addRoute('PATCH', $path, $handler, $middleware, $name);
    }

    public function addRoute(string $method, string $path, callable $handler, array $middleware = [], ?string $name = null): self
    {
        $group = $this->groupStack[count($this->groupStack) - 1];
        $groupPrefix = $group['prefix'];
        $combinedMiddleware = array_merge($group['middleware'], array_values(array_filter($middleware, 'is_callable')));

        $normalizedPath = $this->normalizePath($groupPrefix . '/' . ltrim($path, '/'));
        $this->routes[] = [
            'method' => strtoupper($method),
            'path' => $normalizedPath,
            'handler' => $handler,
            'middleware' => $combinedMiddleware,
        ];

        if ($name !== null && $name !== '') {
            $this->namedRoutes[$name] = [
                'method' => strtoupper($method),
                'path' => $normalizedPath,
            ];
        }
        return $this;
    }

    /**
     * Group routes with optional prefix and middleware.
     * @param array{prefix?:string,middleware?:array} $options
     */
    public function group(array $options, callable $callback): self
    {
        $prefix = $options['prefix'] ?? '';
        $middleware = $options['middleware'] ?? [];

        $current = $this->groupStack[count($this->groupStack) - 1];
        $mergedPrefix = $this->normalizePath($current['prefix'] . '/' . ltrim($prefix, '/'));
        $mergedMiddleware = array_merge($current['middleware'], array_values(array_filter($middleware, 'is_callable')));

        $this->groupStack[] = [
            'prefix' => $mergedPrefix === '/' ? '' : $mergedPrefix,
            'middleware' => $mergedMiddleware,
        ];

        try {
            $callback($this);
        } finally {
            array_pop($this->groupStack);
        }

        return $this;
    }

    public function urlFor(string $name, array $params = []): string
    {
        if (!isset($this->namedRoutes[$name])) {
            throw new \InvalidArgumentException("Route name not found: {$name}");
        }

        $route = $this->namedRoutes[$name];
        $path = $route['path'];

        foreach ($params as $key => $value) {
            $token = '{' . $key . '}';
            if (str_contains($path, $token)) {
                $path = str_replace($token, rawurlencode((string)$value), $path);
                unset($params[$key]);
            }
        }

        if (!empty($params)) {
            $path .= (str_contains($path, '?') ? '&' : '?') . http_build_query($params);
        }

        return $this->normalizePath($path);
    }

    public function dispatch(Request $request): Response
    {
        $requestMethod = $request->method();
        $effectiveMethod = $requestMethod === 'HEAD' ? 'GET' : $requestMethod;

        $matched = null;
        $params = [];
        $allowedMethods = [];

        foreach ($this->routes as $route) {
            $routeParams = [];
            if ($this->matchPath($request->path(), $route['path'], $routeParams)) {
                $allowedMethods[] = $route['method'];
                if ($route['method'] === $effectiveMethod) {
                    $matched = [$route, $routeParams];
                    break;
                }
            }
        }

        if ($matched === null) {
            if ($allowedMethods) {
                $allow = $this->buildAllowHeader($allowedMethods);

                if ($requestMethod === 'OPTIONS') {
                    return Response::text('', 204, ['Allow' => $allow]);
                }

                return Response::methodNotAllowed()->withHeader('Allow', $allow);
            }
            return Response::notFound();
        }

        [$route, $params] = $matched;

        $pipeline = array_merge(
            $this->globalMiddleware,
            $route['middleware'],
            [function (Request $req) use ($route, $params): Response {
                $handler = $route['handler'];
                $result = $handler($req, $params);
                return $this->normalizeResponse($result);
            }]
        );

        $runner = array_reduce(
            array_reverse($pipeline),
            function ($next, $middleware) {
                return function (Request $req) use ($middleware, $next) {
                    return $middleware($req, $next);
                };
            },
            function (Request $req): Response {
                // Fallback should never run; pipeline final handler defined above
                return Response::notFound();
            }
        );

        $response = $runner($request);

        if ($requestMethod === 'HEAD') {
            return $response->withBody('');
        }

        return $response;
    }

    public function run(): void
    {
        $request = Request::fromGlobals();
        $response = $this->dispatch($request);
        $response->send();
    }

    private function normalizePath(string $path): string
    {
        $trimmed = '/' . ltrim($path, '/');
        $normalized = preg_replace('#/+#', '/', $trimmed) ?: '/';
        if (preg_match('#\.{2}[\\/]#', $normalized)) {
            return '/';
        }
        return $normalized === '' ? '/' : $normalized;
    }

    private function matchPath(string $actual, string $pattern, array &$params): bool
    {
        $params = [];
        $aParts = explode('/', trim($actual, '/'));
        $pParts = explode('/', trim($pattern, '/'));

        if (count($aParts) !== count($pParts)) {
            return false;
        }

        foreach ($pParts as $index => $part) {
            $actualPart = $aParts[$index];
            if ($part === '') {
                if ($actualPart !== '') {
                    return false;
                }
                continue;
            }

            if ($part[0] === '{' && substr($part, -1) === '}') {
                $key = trim(substr($part, 1, -1));
                if ($key === '') {
                    return false;
                }
                $params[$key] = $actualPart;
                continue;
            }

            if ($part !== $actualPart) {
                return false;
            }
        }

        return true;
    }

    private function normalizeResponse($result): Response
    {
        if ($result instanceof Response) {
            return $result;
        }

        if (is_string($result)) {
            return Response::text($result);
        }

        if (is_array($result) || is_object($result)) {
            return Response::json($result);
        }

        return Response::text('');
    }

    private function buildAllowHeader(array $allowedMethods): string
    {
        $unique = [];
        foreach ($allowedMethods as $m) {
            $m = strtoupper((string)$m);
            if ($m === '') {
                continue;
            }
            $unique[$m] = true;
        }

        // HEAD is implicitly allowed when GET is present.
        if (isset($unique['GET'])) {
            $unique['HEAD'] = true;
        }

        // OPTIONS should be allowed for matched paths.
        $unique['OPTIONS'] = true;

        $methods = array_keys($unique);
        sort($methods);
        return implode(', ', $methods);
    }
}
